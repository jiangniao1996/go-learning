# MySQL



|     列名      |                             描述                             |
| :-----------: | :----------------------------------------------------------: |
|      id       | 查询语句中每出现一个 select 关键字，MySQL 就会为它分配一个唯一的 id 值，某些子查询会被优化为 join 查询 |
|  select_type  |              SELECT 关键字对应的那个查询的类型               |
|     table     |                             表名                             |
|  partitions   |                        匹配的分区信息                        |
|     type      |             针对单表的查询方式（全表扫描、索引）             |
| possible_keys |                        可能用到的索引                        |
|      key      |                        实际用到的索引                        |
|    key_len    |                      实际用到的索引长度                      |
|      ref      |                          当使用索引                          |





## 海量数据下如何查找一条数据



1. 使用布隆过滤器，快速过滤掉不存在的记录。Redis 情况下可以用 bitmap 结构来实现布隆过滤器。

2. 在 Redis 中建立数据缓存，将我们对 Redis 使用场景的理解，尽量表达出来。可以以普通字符串的小时来存储

   例如 userId-->user.json，以一个hash来存储一条记录（userId -> username -> userAge）。以一个整的 hash来存储所有的数据，

   Userinfo -> field 就用 userId，value 就用 user.json。一个hash最多能支持 2^32-1（40多个亿）个键值对

3. 



## 索引

### 基础知识

**普通索引**：允许被索引的数据列包含重复的值

**唯一索引**：可以保证数据记录的唯一性 （`UNIQUE` `KEY` catename (catid) ）

**主键**：是一种特殊的唯一索引，在一张表中只能定义一个主键索引，主键用于唯一标识一条记录，使用关键字 PRIMARY KEY 来创建

**联合索引**：索引可以覆盖多个数据列，如像 INDEX (column A, column B) 索引

**全文索引**：通过建立倒排索引，可以极大的提升检索效率，解决判断字段是否包含的问题，是目前搜索引擎使用的一种关键技术。可以通过 ALTER TABLE table_name ADD FULLTEXT (column) 来创建全文索引

**最左原则**：

```mysql
CREATE TABLE users (
  last_name varchar(50) not null,
  first_name varchar(50) not null,
  birthday date not null,
  gender enum('m', 'f') not null,
  key(last_name, first_name, birthday)
);
```

该表创建了三个组合索引

username，city，birthday

username，city

username

1. 查询必须从索引的最左边的列开始，否则无法使用到索引。例如下面这条语句就使用不到索引

   ```mysql
   SELECT * FROM users WHERE birthday = NOW();
   ```

2. 存储引擎不能使用索引中范围条件右边的列。例如以下语句，LIKE 是范围查询

   ```mysql
   SELECT * FROM users WHERE last_name = 'Simith' AND first_name LIKE '%Chuck%' AND birthday = NOW();
   ```

3. 不能跳过某一索引列



索引可以极大的提高数据的查询速度，通过索引可以在查询过程中，使用优化隐藏器，提高系统的性能。

但是会降低 insert、delete、update 的速度，因为在执行这些写操作时，还要操作索引文件。

索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要占据的空间就会更大，如果非聚簇索引很多，一旦聚集索引改变，那么所有肥聚集索引都会跟着改变。



**索引覆盖**：

索引覆盖就是一个 SQL 在执行时，可以利用索引来快速查找，并且此 SQL 所要查询的字段在当前索引对应的字段中都包括了，那么就表示此 SQL 走完索引之后就不用回表了，所需要的字段都在当前索引的叶子节点上存在，可以直接作为结果返回了。



### 设计原则

查询更快、占用空间更小

1. 适合索引的列是出现在 where 子句中的列， 或者连接字句中指定的列
2. 基数较小的类，索引效果较差，没有必要再此列建立索引
3. 使用短索引，如果对长字符串进行索引，应该指定一个前缀长度，这样能够大量节省索引空间，如果搜索词超过索引前缀长度，则使用索引排除不匹配的行，然后检查其余行是否可能匹配
4. 不要过度索引，索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就越长。所以只保持需要的索引有利于查询即可。
5. 定义有外键的数据列一定要建立索引
6. 更新频繁的字段不适合创建索引
7. 若是不能有效区分数据的列不适合做索引列（如性别，男女未知，最多也就三种，区分度实在太低）
8. 尽量的扩展索引，不要新建索引。比如表中已经有 a 的索引，现在要加（a，b）的索引，那么只需要修改原来的索引即可
9. 对于那些查询中很少涉及到的列，重复值比较多的列不要建立索引
10. 对于定义为text、image、bit 的数据类型的列不要建立索引



## 数据一致性

1. 先更新 MySQL，再更新 Redis，如果更新 Redis 失败，可能仍然不一致
2. 先删除 Redis 缓存数据，再更新 MySQL，再次查询到的时候将数据添加到缓存中，这种方案能解决1方案的问题，但是在高并发下性能较低，而且仍然可能会出现数据不一致的问题，比如线程1删除了 Redis 缓存数据，正在更新 MySQL，此时另一个线程再查询，那么就会把 MySQL 中的老数据又查到 Redis 中
3. 延时双删，步骤是：先删除 Redis 缓存数据，再更新 MySQL，延迟几百毫秒再删除 Redis 缓存数据，这样就算在更新 MySQL 时，有其他线程读了 MySQL，把老数据读到了 Redis 中，那么也会被删除掉，从而保持数据一致



## 事务

### 基本特性（ACID）

**原子性**：指的是一个事务中的操作要么全部成功，要么全部失败。

**一致性**：指的是数据库总是从一个一致性的状态转换到另外一个一致性的状态。比如 A 给 B 转账 100 块钱，假设 A 只有 90 块，支付之前我们数据库里的数据都是符合约束的，但是如果十五执行成功了，我们的数据库数据就破坏约束了，因此事务不能成功，这里我们说事务提供了一致性的保证。

**隔离性**：指的是一个事务的修改在最终提交前，对其他事务是不可见的。

**持久性**：指的是一旦事务提交，所做的修改就会永久保存到数据库中。



### 隔离级别

- read uncommit 读未提交，可能会读到其他事务未提交的数据，也叫做脏读

  用户本来应该读取到 id = 1 的用户的 age 应该是 10，结果读取到了其他事务还没有提交的事务，读取到了 age = 20，这就是脏读。

- read commit 读已提交，两次读取结果不一致，叫做不可重复读。不可重复读解决了脏读的问题，他只会读取已提交的事务。用户开启事务读取 id = 1 的用户，查询到 age = 10，再次读取发现结果 age = 20，在同一事务里同一个查询读取到不同的结果叫做不可重复读

- repeatable read 可重复读，这是 MySQL 的默认级别，就是每次读取结果都一样，但是有可能产生幻读

- serializable 串行，一般不会使用，他会给每一行读取的数据加锁，会导致大量超市和锁竞争的问题













































































