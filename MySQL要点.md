

|     列名      |                             描述                             |
| :-----------: | :----------------------------------------------------------: |
|      id       | 查询语句中每出现一个 select 关键字，MySQL 就会为它分配一个唯一的 id 值，某些子查询会被优化为 join 查询 |
|  select_type  |              SELECT 关键字对应的那个查询的类型               |
|     table     |                             表名                             |
|  partitions   |                        匹配的分区信息                        |
|     type      |             针对单表的查询方式（全表扫描、索引）             |
| possible_keys |                        可能用到的索引                        |
|      key      |                        实际用到的索引                        |
|    key_len    |                      实际用到的索引长度                      |
|      ref      |                          当使用索引                          |





## 海量数据下如何查找一条数据



1. 使用布隆过滤器，快速过滤掉不存在的记录。Redis 情况下可以用 bitmap 结构来实现布隆过滤器。

2. 在 Redis 中建立数据缓存，将我们对 Redis 使用场景的理解，尽量表达出来。可以以普通字符串的小时来存储

   例如 userId-->user.json，以一个hash来存储一条记录（userId -> username -> userAge）。以一个整的 hash来存储所有的数据，

   Userinfo -> field 就用 userId，value 就用 user.json。一个hash最多能支持 2^32-1（40多个亿）个键值对

3. 



## 索引

### 基础知识

**普通索引**：允许被索引的数据列包含重复的值

**唯一索引**：可以保证数据记录的唯一性 （`UNIQUE` `KEY` catename (catid) ）

**主键索引**：是一种特殊的唯一索引，在一张表中只能定义一个主键索引，主键用于唯一标识一条记录，使用关键字 PRIMARY KEY 来创建

**联合索引**：索引可以覆盖多个数据列，如像 INDEX (column A, column B) 索引

**全文索引**：通过建立倒排索引，可以极大的提升检索效率，解决判断字段是否包含的问题，是目前搜索引擎使用的一种关键技术。可以通过 ALTER TABLE table_name ADD FULLTEXT (column) 来创建全文索引

**最左原则**：

```mysql
CREATE TABLE users (
  last_name varchar(50) not null,
  first_name varchar(50) not null,
  birthday date not null,
  gender enum('m', 'f') not null,
  key(last_name, first_name, birthday)
);
```

该表创建了三个组合索引

username，city，birthday

username，city

username

1. 查询必须从索引的最左边的列开始，否则无法使用到索引。例如下面这条语句就使用不到索引

   ```mysql
   SELECT * FROM users WHERE birthday = NOW();
   ```

2. 存储引擎不能使用索引中范围条件右边的列。例如以下语句，LIKE 是范围查询

   ```mysql
   SELECT * FROM users WHERE last_name = 'Simith' AND first_name LIKE '%Chuck%' AND birthday = NOW();
   ```

3. 不能跳过某一索引列



索引可以极大的提高数据的查询速度，通过索引可以在查询过程中，使用优化隐藏器，提高系统的性能。

但是会降低 insert、delete、update 的速度，因为在执行这些写操作时，还要操作索引文件。

索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要占据的空间就会更大，如果非聚簇索引很多，一旦聚集索引改变，那么所有肥聚集索引都会跟着改变。



**索引覆盖**：

索引覆盖就是一个 SQL 在执行时，可以利用索引来快速查找，并且此 SQL 所要查询的字段在当前索引对应的字段中都包括了，那么就表示此 SQL 走完索引之后就不用回表了，所需要的字段都在当前索引的叶子节点上存在，可以直接作为结果返回了。



### 设计原则

查询更快、占用空间更小

1. 适合索引的列是出现在 where 子句中的列， 或者连接字句中指定的列
2. 基数较小的类，索引效果较差，没有必要再此列建立索引
3. 使用短索引，如果对长字符串进行索引，应该指定一个前缀长度，这样能够大量节省索引空间，如果搜索词超过索引前缀长度，则使用索引排除不匹配的行，然后检查其余行是否可能匹配
4. 不要过度索引，索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就越长。所以只保持需要的索引有利于查询即可。
5. 定义有外键的数据列一定要建立索引
6. 更新频繁的字段不适合创建索引
7. 若是不能有效区分数据的列不适合做索引列（如性别，男女未知，最多也就三种，区分度实在太低）
8. 尽量的扩展索引，不要新建索引。比如表中已经有 a 的索引，现在要加（a，b）的索引，那么只需要修改原来的索引即可
9. 对于那些查询中很少涉及到的列，重复值比较多的列不要建立索引
10. 对于定义为text、image、bit 的数据类型的列不要建立索引



## 数据一致性

1. 先更新 MySQL，再更新 Redis，如果更新 Redis 失败，可能仍然不一致
2. 先删除 Redis 缓存数据，再更新 MySQL，再次查询到的时候将数据添加到缓存中，这种方案能解决1方案的问题，但是在高并发下性能较低，而且仍然可能会出现数据不一致的问题，比如线程1删除了 Redis 缓存数据，正在更新 MySQL，此时另一个线程再查询，那么就会把 MySQL 中的老数据又查到 Redis 中
3. 延时双删，步骤是：先删除 Redis 缓存数据，再更新 MySQL，延迟几百毫秒再删除 Redis 缓存数据，这样就算在更新 MySQL 时，有其他线程读了 MySQL，把老数据读到了 Redis 中，那么也会被删除掉，从而保持数据一致



## 事务

### 基本特性（ACID）

**原子性**（Atomicity）：指的是一个事务中的操作要么全部成功，要么全部失败。

**一致性**（Consistency）：指的是数据库总是从一个一致性的状态转换到另外一个一致性的状态。比如 A 给 B 转账 100 块钱，假设 A 只有 90 块，支付之前我们数据库里的数据都是符合约束的，但是如果十五执行成功了，我们的数据库数据就破坏约束了，因此事务不能成功，这里我们说事务提供了一致性的保证。

**隔离性**（Isolation）：指的是一个事务的修改在最终提交前，对其他事务是不可见的。

**持久性**（Durability）：指的是一旦事务提交，所做的修改就会永久保存到数据库中。



### 隔离级别

- read uncommit 读未提交，可能会读到其他事务未提交的数据，也叫做脏读

  用户本来应该读取到 id = 1 的用户的 age 应该是 10，结果读取到了其他事务还没有提交的事务，读取到了 age = 20，这就是脏读。

- read commit 读已提交，两次读取结果不一致，叫做不可重复读。不可重复读解决了脏读的问题，他只会读取已提交的事务。用户开启事务读取 id = 1 的用户，查询到 age = 10，再次读取发现结果 age = 20，在同一事务里同一个查询读取到不同的结果叫做不可重复读

- repeatable read 可重复读，这是 MySQL 的默认级别，就是每次读取结果都一样，但是有可能产生幻读

- serializable 串行，一般不会使用，他会给每一行读取的数据加锁，会导致大量超市和锁竞争的问题



## 慢查询如何优化

**开启慢查询日志**

1. 检查是否走了索引，如果没有则优化SQL利用索引
2. 检查所利用的索引，是否是最优索引
3. 检查所查字段是否都是必须的，是否查询了过多字段，查出了多余数据
4. 检查表中数据是否过多，是否应该进行分库分表了
5. 检查数据库实例所在机器性能配置，是否太低，是否可以适当增加资源





## select * 问题

1. 尽量不要使用 select *，只取自己需要的字段，过多的字段会造成解析开销和网络带宽开销
2. select * 可能会用不到索引覆盖，即使用到也需要回表

```mysql
CREATE TABLE users (
  id int(11) auto_increment,
  name varchar(50) not null,
  age date not null,
  key(name),
  primary key(id)
);
```

不用回表，因为 `name` 字段作为非聚集索引会存储主键 `id` 的值：

```mysql
select id, name from users where name = 'jhon';
```

需要回表，因为 `age` 字段并没有建立索引，在 `name` 索引上得不到 `age` 的值

```mysql
select id, name, age from users where name = 'jhon';
```



## 聚簇索引和非聚簇索引

都是 B+ 树的结构数据

- 聚簇索引：将数据存储和索引放到了一块，并且是按照一定的顺序组织的，找到索引也就找到了数据，数据的物理存放顺序与索引顺序是一致的。即：只要索引是相邻的，那么对应的数据也一定是相邻的存放在磁盘上
- 非聚簇索引：叶子节点不存储数据，存储的是数据行地址，也就是说根据索引查找到数据行的位置再取磁盘查找数据，这个就有点类似一本书的目录，比如我们要找第三章第一节，那么我们就先在这个目录里面找，找到对应的页码后再去对应的页码查看文章。

**聚簇索引之优劣**

优势：

1. 查询通过聚簇索引可以直接获取数据，相比非聚簇索引需要回表（非覆盖索引的情况下）效率要高
2. 聚簇索引对于范围查询的效率很高，因为其数据时按照大小排列的
3. 聚簇索引适合用在排序的场合，非聚簇索引不合适

劣势：

1. 维护索引很昂贵，特别是插入新行或者主键被更新导致要分页（page split）的时候，建议在大量插入新行后，选在负载较低的时间段，通过OPTIMIZE TABLE优化表，因为必须被移动的行数据可能造成碎片。使用独享空间可以弱化碎片。
2. 表因为使用 `UUID`（随机ID）作为 主键，使数据稀疏，这就会出现聚簇索引有可能比全表扫描更慢，索引建议使用 int 的auto_increment 作为主键
3. 如果主键比较大的话，那么辅助索引将会变得更大，因为辅助索引的叶子存储的是主键值，过长的主键值，会导致非叶子节点占用更多的物理空间



## 锁的类型

基于锁的属性分类：共享锁，排他锁。

觊觎锁的粒度分类：行级锁（INNODB）、表级锁（INNODB\MYISAM）、页级锁（BDB引擎）、记录锁、间隙锁、临键锁。

基于锁的状态分类：意向共享锁、意向排他锁。

- 共享锁（Share Lock）

```mysql
select * from users where id = 1 lock in share mode;
```

```
共享锁由称为读锁，简称S锁，当一个事务为数据加上读锁之后，其他事务只能对该数据加读锁，而不能对数据加写锁，直到所有读锁释放之后其他事务才能对其进行加持写锁。共享锁的特性主要是为了支持并发读取数据，读取数据的时候不支持修改，避免出现重复读的问题。
```



- 排他锁（Exclusive Lock）

```mysql
select * from users where id = 1 for update;
```

```
排他锁又称写锁，简称X锁，当一个事务为数据加上写锁时，其他请求将不能再为数据加任何锁，直到该锁释放之后，其他事务才能对数据进行加锁。排他锁的目的是在数据修改时候，不允许其他人同时修改，也不允许其他人读取。避免了出现脏数据和脏读的问题。
```

- 表锁

```
表锁是指上锁的时候锁住的是整个表，当下一个事务访问该表的时候，必须等一个事务释放了锁才能进行对表进行访问。
```

- 行锁

```
行锁是指上锁的时候锁住的是表的某一行或多行记录，其他事务访问同一张表时，只有被锁住的记录不能访问，其他的记录可以正常访问。
```

- 记录锁（Record Lock）

```
记录锁属于行锁中的一种，只不过记录锁的范围只是表中的某一条记录。
加了记录锁之后数据可以避免数据在查询的时候被修改的重复读问题，也避免了在修改的事务未提交前被其他事务读取的脏读问题。
```

- 间隙锁（Gap Lock）


```
属于行锁的一种，间隙锁是在事务加锁后其锁住的是表记录的某一个区间，当表的相邻ID之间出现空隙则会形成一个区间，遵循左开右闭原则。
范围查询并且未命中记录，查询条件必须命中索引，间隙锁只会出现在 REPEATABLE_READ（重复读）的事务级别中。
触发条件：防止幻读问题，事务并发的时候，如果没有间隙锁，就会发生同一个事务A里，两次查询出的结果不一样。
```

- 临键锁（Next-Key Lock）


```
也属于行锁的一种，并且它是INNODB的行锁默认算法，总结来说它就是记录锁和间隙锁的组合，临键锁会把查询出来的记录锁住，同时也会把该范围查询内所有的间隙空间也锁住。
```



悲观锁

select * from users where id = 1 for update;

乐观锁

version





## 索引的本质























