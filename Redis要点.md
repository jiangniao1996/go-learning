## 缓存雪崩

**指缓存同一时间大面积的失效，所以后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉**

解决方法：

- 缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生
- 给每一个缓存数据增加相应的缓存标记，记录缓存是否失效，如果缓存失效，则更新数据缓存（比较消耗性能）
- 缓存预热
- 互斥锁，假如查到一个缓存失效了，去查数据库的时候把该缓存的key锁起来，查完数据库并放到缓存中之后，再释放这个锁

## 缓存穿透

**指的是缓存和数据库中都没有的数据，导致所有请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉**

解决方法：

- 接口层增加校验，如用户鉴权校验，id做基础校验，id <= 0 的直接拦截
- 从缓存中获取不到的数据，在数据库中也没有取到，可以将 key-value 对写为 key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止用户反复用同一个id暴力攻击
- 使用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力

## 缓存击穿

**缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这是由于并发用户特别多，同时读取缓存没有读到数据，又同时去数据库读取数据，导致数据库压力瞬间增大。**

解决方法：

- 设置热点数据永不过期
- 互斥锁



**大KEY删除**







## 集群方案



### 主从模式

master slave



### 哨兵模式

sentinel，哨兵是redis集群中非常重要的一个组件，主要有以下功能：

- 集群监控：负责监控 redis master 和 salve 进程是否正常工作
- 消息通知：如果某个 redis 实例又故障，那么哨兵会负责发消息作为报警通知给管理员
- 故障转移：如果 master node 挂掉了，会自动转移到 slave node 上
- 配置中心：如果故障转移发生了，通知client客户端新的 master 地址

哨兵用于实现 redis 集群的高可用，本身也是分布式的，作为一个哨兵集群去运行，互相协同工作。

- 故障转移时，判断一个 master node 是否宕机了，需要大部分哨兵都同意才行，涉及到了分布式选举
- 即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的
- 哨兵通常需要 3 个实例，来保证自己的健壮性
- 哨兵 + redis 主从的部署架构，是不保证数据 0 丢失的，只能保证 redis 集群的高可用性
- 对于哨兵 + redis 主从这种复杂的部署结构，尽量在测试环境和生产环境都进行充足的测试和演练



### Cluster模式

Redis Cluster 是一种服务端的 Sharding 技术，3.0 版本开始正式提供，采用 slot（槽）的概念，一共分成了 16384 个槽位，将请求发送到任意节点，接收到请求的节点将会查询请求发送到正确的节点上执行

- 通过哈希的方式，将数据切片，每个节点均分布存储一定哈希槽（哈希值）区间的数据，默认分配了 16384 个槽位
- 每份数据会存储在多个互为主从的多节点上
- 数据写入先写主节点，再同步到从节点（支持配置为阻塞同步）
- 同一分片多个节点间的数据不保持强一致性
- 读取数据时，当客户端操作的 key 没有分配在该节点上时，redis 会返回转向指令，指向正确的节点
- 扩容时需要把旧节点的数据迁移一部分到新节点



## 数据结构

### String（字符串）

分布式锁，可以用 set 将 setnx + setex 变成原子操作





### List（列表）

lpush

lpop

rpush

rpop



### Hash（哈希）





### Set（无序集合）

sadd key member：添加记录

srem key member：删除记录

smembers key：获取记录所有 value

sdiff key1 key2：对比不同

sinter key1 key2：对比相同



### Sorset Set（有序集合）

```bash
zadd users 1 'jhon' # 添加数据 score为1
zrem users 'jhon' # 移除数据
zrange users 0 -1 withscores # 展示集合里所有元素并显示score
```



### bitmap（位图）

可用于签到，布隆过滤器

```bash
setbit sign:1001:202106 1 1 # 用户1001在2021年6月1号签到了
```



###  GeoHash

坐标，地理位置，用于实现附近的人



### HyperLogLog

统计不重复数据，用大数据基数统计



### Streams

用于实现消息订阅发布



### 使用场景

1、缓存

String 类型，比如热点数据缓存，对象缓存，全页缓存，可以提升热点数据的访问数据



2、分布式锁

set



3、限流

int 类型，incr 方法

以访问者的ip和其他信息作为key，访问一次增加一次计数，超过次数则返回false



4、抽奖

随机抽取一个获得值

spop myset



5、微博点赞

比如有微博文章 id 为 t1001，用户 id 为 u3001

```bash
sadd like:t1001 u3001 # 点赞了这条微博
srem like:t1001 u3001 # - 取消点赞
- ：sismember like:t1001 u3001 # 是否点赞
- ：smembers like:1001 # 点赞的所有用户
scard like:t1001 # 点赞数
```



6、商品标签

假设有商品 id 为 i5001

```bash
sadd tags:i5001 # 画面清晰细腻
sadd tags:i5001 # 真彩清晰显示屏
sadd tags:i5001 # 流畅至极
```



7、用户关注、推荐模型

follow 关注 fans 粉丝

相互关注

```bash
sadd 1001:follow 1002
sadd 1002:fans 1001
sadd 1001:fans 1002
sadd 1002:follow 1001
```

我关注的人也关注了他（取交集）：

```bash
sister 1001:follow 1002:fans
```

可能认识的人：

- 用户1001可能认识的人（差集）

  ```bash
  sdiff 1002:follow 1001:follow
  ```

- 用户1002可能认识的人

  ```bash
  sdiff 1001:follow 1002:follow
  ```



8、排行榜

id 为 6001 的新闻点击数加1

```text
zincrby hotNews:20211018 1 6001
```

获取今天点击最多的15条

```text
zrevrange hotNews:20211018 0 15 withscores
```





## 持久化机制

### RDB

即 Redis Database 将某一时刻的内存快照（Snapshot），以二进制的方式写入磁盘

**手动触发：**

- save 命令，使 Redis 处于阻塞状态，知道 RDB 持久化完成，才会响应其他客户端发来的命令，所以在生产环境中一定要慎用
- bgsave 命令，fork 出一个子进程进行持久化，主进程只在 fork 过程中又短暂的阻塞，子进程创建之后，主进程就可以响应客户端请求了，注意此时 Redis 采取的方案是 COW（Copy On Write），相当于此时生成的快照将会是该时刻的，不会随着时间的流逝而形成数据不一致

**自动触发：**

- save m n：在 m 秒内，如果有 n 个键发生改变，则自动触发持久化，通过 bgsave 执行，如果设置多个，只要满足其一就会触发，配置文件有默认配置（可以注释掉）
- flushall：用于清空 redis 所有的数据库，flushdb 用于清空当前所在库数据，会清空 RDB 文件，同时也会生成 dump.rdb，内容为空
- 主从同步：全量同步时会自动触发bgsave命令，生成 rdb 发送给从节点

**优点：**

1. 整个 Redis 数据库只包含一个文件 dump.rdb，方便持久化
2. 容灾性好，方便备份
3. 性能最大化，fork 子进程完成写操作，让主进程继续处理



### AOF

Append Only File 即以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录，调操作系统命令进程刷盘

1. 所有写命令会追加到 AOF 缓冲中
2. AOF 缓冲区根据相对应的策略向硬盘进行同步操作
3. 随着 AOF 文件越来越大，需要定期对 AOF 文件进行重写，达到压缩的目的（比如多条 set a、set b 会被重写为 set a b）
4. 当 Redis 重启时，可以加载 AOF 文件进行数据恢复

**同步策略：**

- 每秒同步：异步完成，效率非常高，一旦系统出现宕机现象，那么这一秒钟之内修改的数据将会丢失
- 每修改同步：同步持久化，每次发生的数据变化都会被立即记录到磁盘中，最多丢失一条
- 不同步：由操作系统控制，可能丢失较多数据

**优点：**

1. 数据安全
2. 通过 append 模式写文件，即使中途服务器宕机也不会破坏已经存在的内容，可以通过 redis-check-aof 工具解决数据一致性问题
3. AOF 机制的 rewrite 模式，定期对 AOF 文件进行重写，以达到压缩的目的

**缺点：**

1. AOF 文件比 RDB 文件大，且恢复速度慢
2. 数据集大的时候，比 RDB 启动效率低
3. 运行效率没有 RDB 高



## 数据一致性







## 事务



**事务开始**

MULTI 命令的执行，标志着一个事务的开始。MULTI 命令会将客户端状态的 `flags` 属性中打开 `REDIS_MULTI` 标志来完成。



**命令入队**

当一个客户端切换到事务状态之后，服务器会根据这个客户端发送来的命令来执行不同的操作。如果客户端发送的命令为 MULTI、

EXEC、WATCH、DISCARD 中的一个，立即执行这个命令，否则将命令放入一个事务队列里面，然后向客户端返回 `QUEUED` 回复

- 如果客户端发送的命令为 EXEC、DISCARD、WATCH、MULTI 四个命令中的其中一个，那么服务器立即执行这命令

- 如果客户端发送的是四个命令以外的其他命令，那么服务器并不执行这命令

  首先检查此命令格式是否正确，如果不正确，服务器会在客户端状态（redisClient）的 flags 属性关闭 `REDIS_MULTI` 标志，并且将错误信息返回客户端。如果正确，将这个命令放入一个事务队列里面，然后向客户端返回 QUEUED 回复

事务队列是按照 FIFO 的方式保存入队的命令



**事务执行**

客户端发送 EXEC 命令，服务器执行 EXEC 命令逻辑

- 如果客户端状态的 flags 属性不包含 `REDIS_MULTI` 标志，或者包含 REDIS_DIRTY_CAS 或者 REDIS_DIRTY_EXEC 标志，那么会直接取消事务的执行
- 否则客户端处于事务状态（flags 有 REDIS_MULTI 标志），服务器会遍历客户端的事务队列，然后执行事务队列中的所有命令，最后将返回结果全部返回给客户端

Redis 不支持事务回滚机制，但是它会检查每一个事务中的命令是否错误。

Redis 事务不支持检查那些程序员自己逻辑错误，例如对 String 类型的数据库键执行对 HashMap 类型的操作。

- WATCH 命令是一个乐观锁，可以为 Redis 事务提供 check-and-set（CAS）行为，可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到 EXEC 命令
- MULTI 命令用于开启一个事务，它总是返回 OK，MULTI 执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会被立即执行，而是被放到一个队列中，当 EXEC 命令被调用时，所有队列中的命令才会被执行
- EXEC：执行所有事务块内的命令，返回事务块内所有命令的返回值，按命令执行的先后顺序排列。当操作被打断时，返回空值 nil
- 通过调用 DISCARD，客户端可以清空事务队列，并放弃执行事务，并且客户端会从事务状态中退出
- UNWATCH 命令可以取消 WATCH 对所有 KEY 的监控





































