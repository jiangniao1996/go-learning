# Redis



## 缓存雪崩

**指缓存同一时间大面积的失效，所以后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉**

###### 解决方法：

- 缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生
- 给每一个缓存数据增加相应的缓存标记，记录缓存是否失效，如果缓存失效，则更新数据缓存（比较消耗性能）
- 缓存预热
- 互斥锁，假如查到一个缓存失效了，去查数据库的时候把该缓存的key锁起来，查完数据库并放到缓存中之后，再释放这个锁

## 缓存穿透

**指的是缓存和数据库中都没有的数据，导致所有请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉**

###### 解决方法：

- 接口层增加校验，如用户鉴权校验，id做基础校验，id <= 0 的直接拦截
- 从缓存中获取不到的数据，在数据库中也没有取到，可以将 key-value 对写为 key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止用户反复用同一个id暴力攻击
- 使用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力

## 缓存击穿

**缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这是由于并发用户特别多，同时读取缓存没有读到数据，又同时去数据库读取数据，导致数据库压力瞬间增大。**

###### 解决方法：

- 设置热点数据永不过期
- 互斥锁



## 集群方案



###### 主从模式：

master slave



###### 哨兵模式：

sentinel，哨兵是redis集群中非常重要的一个组件，主要有以下功能：

- 集群监控：负责监控 redis master 和 salve 进程是否正常工作
- 消息通知：如果某个 redis 实例又故障，那么哨兵会负责发消息作为报警通知给管理员
- 故障转移：如果 master node 挂掉了，会自动转移到 slave node 上
- 配置中心：如果故障转移发生了，通知client客户端新的 master 地址

哨兵用于实现 redis 集群的高可用，本身也是分布式的，作为一个哨兵集群去运行，互相协同工作。

- 故障转移时，判断一个 master node 是否宕机了，需要大部分哨兵都同意才行，涉及到了分布式选举
- 即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的
- 哨兵通常需要 3 个实例，来保证自己的健壮性
- 哨兵 + redis 主从的部署架构，是不保证数据 0 丢失的，只能保证 redis 集群的高可用性
- 对于哨兵 + redis 主从这种复杂的部署结构，尽量在测试环境和生产环境都进行充足的测试和演练



###### Cluster模式

Redis Cluster 是一种服务端的 Sharding 技术，3.0 版本开始正式提供，采用 slot（槽）的概念，一共分成了 16384 个槽位，将请求发送到任意节点，接收到请求的节点将会查询请求发送到正确的节点上执行

- 通过哈希的方式，将数据切片，每个节点均分布存储一定哈希槽（哈希值）区间的数据，默认分配了 16384 个槽位
- 每份数据会存储在多个互为主从的多节点上
- 数据写入先写主节点，再同步到从节点（支持配置为阻塞同步）
- 同一分片多个节点间的数据不保持强一致性
- 读取数据时，当客户端操作的 key 没有分配在该节点上时，redis 会返回转向指令，指向正确的节点
- 扩容时需要把旧节点的数据迁移一部分到新节点





 







































